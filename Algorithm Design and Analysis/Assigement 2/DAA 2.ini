1.

sequentialSearch(S,k):
    //Input: sequencia desordenada S, e um elemento, k
    //Output: Boolean

    for i= 1...len(S):
        if S[i]==k:
            return true
    return false

Explica√ß√£o: 
A estrat√©gia utilizada na resolu√ß√£o deste problema √© a "Decrease and Conquer".
Este tipo de estrat√©gia consiste na itera√ß√£o sequencial sobre os elementos da sequ√™ncia, avaliando em cada itera√ß√£o se cada um destes corresponde ao elemento procurado.
No caso positivo, termina a procura e √© retornado um valor true. Por outro lado, se o elemento n√£o estiver na sequ√™ncia, ap√≥s iterar sobre todos os elementos, √© retornado um valor false.

2.
Em cada itera√ß√£o do algoritmo acima ocorre uma opera√ß√£o de soma (iterador "i" do ciclo for), um acesso (acesso ao elemento de indice "i" da sequ√™ncia) e uma compara√ß√£o.
O trabalho, em n√∫mero de passos elementares, √© dado por:
T(n)=3(t-1+1)=3t onde t √© o numero de itera√ß√µes ocorridas do ciclo for, 1<=t<=n, e 'n' o tamanho da sequ√™ncia (n=len(S)).

No melhor caso o elemento procurado corresponde ao elemento na primeira posi√ß√£o da sequ√™ncia, isto √©, ocorre apenas uma itera√ß√£o no ciclo for:
    t=1
    B(n)=3, O(3)=O(1) a ordem de complexidade √© constante para qualquer tamanho de sequ√™ncia
            
No pior caso o elemento de procura n√£o se encontra na sequ√™ncia, isto √©, ocorrem tantas itera√ß√µes quanto o tamanho da sequ√™ncia:
    t=n
    W(n)=3n,  O(3n)=O(n) a ordem de complexidade √© linear e depende do tamanho da sequ√™ncia

No caso medio o elemento procurado corresponde ao elemento na posi√ß√£o n/2 da sequ√™ncia, isto √©, ocorrem n/2 itera√ß√µes no ciclo for: 
    t=n/2
    A(n)=3(n/2), O(3n/2)=O(n)  a ordem de complexidade √© linear e depende do tamanho da sequ√™ncia

Logo, no geral, a ordem de complexidade desta pesquisa √© O(n) para o limite superior e ùõÄ(1) para o limite inferior.


3.


4. 
binarySearch(S,L,H,K):
    //Input: sequencia ordenada S, indice de inicio de procura L, indice de fim de procura H e um elemento, K 
    //Output: Boolean

    M = (H+L)/2
    if L==H:
        return false
    if K<S[M]:
        binarySerach(S,L,M,K)
    else if K>S[M]:
        binarySerach(S,M,H,k)
    else:
        return true
        
Explica√ß√£o: 
A estrat√©gia utilizada na resolu√ß√£o deste problema √© a "Divide and Consquer".
Este tipo de estrat√©gia consiste numa divis√£o da sequ√™ncia ordenada em duas subsequ√™ncias. Depois, mediante uma avalia√ß√£o dos indices L e H (indices de inicio e fim da sequ√™ncia em que ocorreu a pesquisa) e 
dos valores do indice m√©dio, entre L e H, e o valor procurado √© feita uma paragem ou uma recursividade.


6.
binarySearchFirstPositive(S,L,H):
    //Input: sequencia Ordenada S, indice de inicio de procura L, indice de fim de procura H
    //Output: K indice do primeiro inteirio positivo

    M=(H+L)/2
    if L==M:
        return -1
    else if S[M]>0:
        if M-1>0 && S[M-1]>0:
            binarySearchFirstPositive(S,L,M)
        else:
            return M
    else if S[M]<0:
        if S[M+1]>0:
            return M+1
        else:
            binarySearchFirstPositive(S,M,H)
    else:
        return M+1
        
binarySearchIntIndex(S,L,H):
    //Input: sequencia Ordenada S, indice de inicio de procura L, indice de fim de procura H
    //Output: K indice do primeiro inteirio positivo

    M=(H+L)/2

    if L==M:
        return -1
    if S[M]>M:
        binarySearchIntIndex(S,L,M)
    else if S[M]<M:
        binarySearchIntIndex(S,M,H)
    else:
        return M



abc(S,M,H)
    //Input
    //Output

    if H < L :
        return -1
        
    M=(H+L)/2
    
    if S[M]>M:
        abc(S,L,M)
    else if S[M]<M:
        abc(S,M,H)
    else 
        return M
